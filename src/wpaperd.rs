use std::fs::File;
use std::io::Write;
use std::process::{Command, Stdio};
use toml::{Value, to_string_pretty};
use crate::splitter::ResultPaper;

pub struct WpaperdConfig {
    pub config_path: String,
    pub config_hash: String
}

impl WpaperdConfig {
    pub fn new(config_path: String, config_hash: String) -> Self {
        Self {
            config_path,
            config_hash
        }
    }

    // build new wpaperd config to file
    pub fn build(&self, wallpapers: &Vec<ResultPaper>) -> Result<(), String> {
        // Create a new config file
        let mut file = File::create(&self.config_path).map_err(
            |_| "unable to open config"
        )?;

        // Open the file
        let read_file = std::fs::read_to_string(&self.config_path).map_err(
            |_| "unable to read config"
        )?;

        // Parse the string into a TOML value
        let mut values = read_file.parse::<Value>().map_err(
            |_| "unable to parse config"
        )?;

        // Add new output sections
        for monitor in wallpapers {
            // insert new section
            values.as_table_mut().unwrap().insert(
                monitor.monitor_name.to_string(), 
                Value::Table(Default::default())
            );
            // add path value
            let path = values.get_mut(
                monitor.monitor_name.to_string()
            ).unwrap();
            path.as_table_mut().unwrap().insert(
                "path".to_string(),
                Value::String(monitor.image_full_path.to_string())
            );
        }

        // write the file
        file.write(self.config_hash.as_bytes()).unwrap();
        file.write(b"# AUTOGENERATED CONFIG BY RWPSPREAD\n\n").unwrap();
        file.write_all(to_string_pretty(&values).unwrap().as_bytes()).unwrap();

        // return
        Ok(())
    }

    // check for existing config
    pub fn check_existing(&self) -> Result<bool, String> {
        // Open the file
        let read_file = std::fs::read_to_string(&self.config_path).map_err(
            |_| "unable to open config"
        )?;

        // check if we find the correct hash
        if read_file.starts_with(&self.config_hash) {
            // hash matches, don't regenerate
            return Ok(true) 
        }

        // return
        Ok(false)
    }
}

pub fn cmd_wrapper() -> Result<(), String> {
    // Check if there is a running wpaperd process
    match Command::new("pidof")
        .args(&["wpaperd"])
        .stdout(Stdio::null())
        .status() {
            Ok(_) => {
                // kill it with fire
                Command::new("killall")
                    .args(&["-9", "wpaperd"])
                    .stdout(Stdio::null())
                    .output().map_err(
                        |err| err.to_string()
                    )?;
            },
            Err(_) => {},
    }

    // Spawn new wpaperd instance
    Command::new("wpaperd")
        .spawn().map_err(
            |err| err.to_string()
        )?;
    
    Ok(())
}
