use std::fs::File;
use std::io::Write;
use std::process::{Command, Stdio, exit};
use toml::{Value, to_string_pretty};
use crate::splitter::ResultPaper;

pub struct WpaperdConfig {
    pub config_path: String,
    pub papers: Vec<ResultPaper>,
    pub hash: String
}

impl WpaperdConfig {
    pub fn new(path: String, wallpapers: Vec<ResultPaper>, hash: String) -> Self {
        Self {
            config_path: path,
            papers: wallpapers,
            hash
        }
    }
    pub fn build(&self) -> Result<(), String> {
        // Create a new config file
        let mut file = File::create(&self.config_path).map_err(
            |_| "unable to open config"
        )?;

        // Open the file
        let read_file = std::fs::read_to_string(&self.config_path).map_err(
            |_| "unable to read config"
        )?;

        // Parse the string into a TOML value
        let mut values = read_file.parse::<Value>().map_err(
            |err| err.to_string()
        )?;

        // Add new output sections
        for monitor in &self.papers {
            // insert new section
            values.as_table_mut().unwrap().insert(
                monitor.monitor_name.to_string(), 
                Value::Table(Default::default())
            );
            // add path value
            let path = values.get_mut(
                monitor.monitor_name.to_string()
            ).unwrap();
            path.as_table_mut().unwrap().insert(
                "path".to_string(),
                Value::String(monitor.image_full_path.to_string())
            );
        }

        // write the file
        file.write(self.hash.as_bytes()).unwrap();
        file.write(b"# AUTOGENERATED CONFIG BY RWPSPREAD\n\n").unwrap();
        file.write_all(to_string_pretty(&values).unwrap().as_bytes()).unwrap();

        // return
        Ok(())
    }
}

// check for existing config
pub fn check_existing(path: &String, base_hash: &String) -> Result<bool, String> {
    // Open the file
    let read_file = std::fs::read_to_string(path).map_err(
        |_| "unable to open config"
    )?;

    if read_file.starts_with(base_hash) {
        // hash matches, don't regenerate
        return Ok(true) 
    }

    // return
    Ok(false)
}

pub fn cmd_wrapper() -> Result<(), String> {
    // Check if there is a running wpaperd process
    match Command::new("pidof")
        .args(&["wpaperd"])
        .stdout(Stdio::null())
        .status() {
            Ok(_) => {
                // kill it with fire
                Command::new("killall")
                    .args(&["-9", "wpaperd"])
                    .stdout(Stdio::null())
                    .output().map_err(
                        |err| err.to_string()
                    )?;
            },
            Err(_) => {},
    }

    // Spawn new wpaperd instance
    Command::new("wpaperd")
        .spawn().map_err(
            |err| err.to_string()
        )?;
    
    // exit
    exit(0);
}
