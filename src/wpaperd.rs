use crate::splitter::ResultPaper;
use std::env::var;
use std::fs::File;
use std::io::Write;
use std::process::{Command, Stdio};
use toml::{to_string_pretty, Value};

pub struct WpaperdConfig {
    pub config_hash: String,
    config_path: String,
}

impl WpaperdConfig {
    pub fn new(config_hash: String) -> Self {
        Self {
            config_hash,
            config_path: format!("{}/.config/wpaperd/wallpaper.toml", var("HOME").unwrap()),
        }
    }

    // build new wpaperd config to file
    pub fn build(&self, wallpapers: &Vec<ResultPaper>) -> Result<(), String> {
        // Create a new config file
        let mut config_file =
            File::create(&self.config_path).map_err(|_| "unable to open config")?;

        // Open the file
        let read_file =
            std::fs::read_to_string(&self.config_path).map_err(|_| "unable to read config")?;

        // Parse the string into a TOML value
        let mut values = read_file
            .parse::<Value>()
            .map_err(|_| "unable to parse config")?;

        // Add new output sections
        for fragment in wallpapers {
            // insert new section
            values.as_table_mut().unwrap().insert(
                fragment.monitor_name.to_string(),
                Value::Table(Default::default()),
            );
            // add path value
            let path = values.get_mut(fragment.monitor_name.to_string()).unwrap();
            path.as_table_mut().unwrap().insert(
                "path".to_string(),
                Value::String(fragment.full_path.to_string()),
            );
        }

        // write the file
        config_file
            .write(format!("# {}\n", self.config_hash).as_bytes())
            .unwrap();
        config_file
            .write(b"# DO NOT EDIT! AUTOGENERATED CONFIG!\n\n")
            .unwrap();
        config_file
            .write_all(to_string_pretty(&values).unwrap().as_bytes())
            .unwrap();

        // return
        Ok(())
    }

    // check for existing config
    pub fn check_existing(&self) -> bool {
        // Open the file
        let read_file = std::fs::read_to_string(&self.config_path).unwrap_or_default();

        // check if we find the correct hash
        if read_file.starts_with(&format!("# {}", self.config_hash)) {
            // hash matches, don't regenerate
            return true;
        }

        false
    }
}

pub struct CmdWrapper {}

impl CmdWrapper {
    // check if running, if not run
    pub fn restart() -> Result<(), String> {
        // Check if there is a running wpaperd process
        match Command::new("pidof")
            .args(&["wpaperd"])
            .stdout(Stdio::null())
            .status()
        {
            Ok(status) => {
                if status.success() {
                    // kill it with fire
                    Command::new("killall")
                        .args(&["-9", "wpaperd"])
                        .stdout(Stdio::null())
                        .output()
                        .map_err(|err| err.to_string())?;
                }
            }
            Err(e) => return Err(e.to_string()),
        }

        // Spawn new wpaperd instance
        Command::new("wpaperd")
            .spawn()
            .map_err(|err| err.to_string())?;

        Ok(())
    }

    // kill first, then restart
    pub fn soft_restart() -> Result<(), String> {
        // Check if there is a running wpaperd process
        match Command::new("pidof")
            .args(&["wpaperd"])
            .stdout(Stdio::null())
            .status()
        {
            Ok(status) => {
                if !status.success() {
                    // Spawn new wpaperd instance
                    Command::new("wpaperd")
                        .spawn()
                        .map_err(|err| err.to_string())?;
                }
            }
            Err(e) => return Err(e.to_string()),
        }

        Ok(())
    }
}
